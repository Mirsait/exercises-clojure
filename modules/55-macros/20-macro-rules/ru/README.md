Теперь посмотрим, как выполняется код внутри макросов:

```clojure
(defmacro id-mac [x]
  "Hello, macro!"
  x)

(macroexpand-1 '(id-mac (println "str")))
; => (println "str")
```

Как видно из примера, строка, `"Hello, macro!"` нигде не появилась, следовательно, как и в обычной функции, возвращается последняя форма. Вспомним макрос из прошлого упражнения:

```clojure
(defmacro identity-macro [x]
  (println "identity of x")
  x)
```

Как мы уже выяснили, когда мы вызываем `identity-macro`, форма `(println "identity of x")` вызывается до возвращения последней формы, что еще раз подтверждает, что тело макроса выполняется так же как и в обычной функции. Это будет вторым правилом макросов: Тело макросов выполняется в соответствии с обычными правилами Clojure.

Посмотрим еще несколько функций и макросов:

```clojure
(defn triplet-fn [a b c]
  (list a b c))

(defmacro triplet-macro [a b c]
  (list a b c))

(triplet-fn 1 2 3)
; => (1 2 3)

(triplet-macro 1 2 3)
; => java.lang.Exception: Cannot call 1 as a function.

; Что-то пошло не так, посмотрим, во что макрос разворачивается

(macroexpand '(triplet-macro 1 2 3))
; => (1 2 3)

; Хм, кажется все начинает сходиться, попробуем вызвать макрос напрямую
(eval (macroexpand '(triplet-macro 1 2 3)))
; => java.lang.Exception: Cannot call 1 as a function.

; Ошибка такая же, как и в примере выше, Clojure пытается
; выполнить код (1 2 3), который не является валидной формой
```

Пора подводить итоги! Из примера выше можно сформировать еще одно, третье правило макросов: Данные, возвращаемые макросом немедленно вычисляются и результат этого вычисления отдается наружу при вызове этого макроса (третье правило не совсем корректно, но для нынешнего понимания этого пока что достаточно).

Полезно помнить, что возвращаемая форма выполняется дважды, когда вы пишете макрос и единожды, когда пишете обычную функцию. Теперь вспомним еще раз все правила, которые сформулировали:

- Аргументы не выполняются перед тем, как были отправлены в тело макроса;
- Тело макросов выполняется в соответствии с обычными правилами Clojure;
- Данные, возвращаемые макросом немедленно вычисляются и результат этого вычисления отдается наружу при вызове этого макроса.
