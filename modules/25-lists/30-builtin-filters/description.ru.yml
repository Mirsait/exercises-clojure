---

name: Фильтрация списков, filter
theory: |
  Функция `map` может менять элементы списка, но не может менять их количество: сколько элементов было в исходном списке, столько же останется и в результирующем. Функция `filter` же, напротив, не может менять сами элементы, но может решать, какие из них попадут в выходной список, а какие будут отброшены. Так `map` и `filter`, выполняя каждая свою задачу, взаимно дополняют друг друга!
  ### `filter`
  Функция `filter` принимает два аргумента:
  1. Функцию-предикат, которая должна вернуть `true` для тех элементов, которые нужно оставить
  2. Список элементов для последующего отбора
  Результатом вызова `filter` будет *новый* список, содержащий элементы, одобренные аргументом-предикатом.
  Благодаря тому, что в Clojure доступно великое множество функций-предикатов, использовать `filter` легко и удобно:

  ```clojure
  (filter int? (list 1 2.5 "foo" 7))     ; '(1 7)
  (filter pos? (list -1 5 42 0 -100 3)) ; '(5 42 3)
  ```

instructions: |
  Реализуйте функцию `increment-numbers`, которая берёт из списка-аргумента значения, являющиеся числами (`number?`) и возвращает список этих чисел, увеличив предварительно каждое число на единицу (`inc`). Пример:

  ```clojure
  (increment-numbers (list 10 "foo" false (list 2 3) 3/5)) ; '(11 8/5)
  ```

  > Заметьте, Clojure умеет работать с дробями вроде `3/5` и `8/5`!

tips:
  - |
    [Официальная документация](https://clojuredocs.org/clojure.core/filter)
