---

name: Объявление списков
theory: |
  ### Функция `list` и цитирование
  В языке, призванном работать со списками просто обязан существовать синтаксис для объявления литералов списков. Проще всего воспользоваться функцией с именем `list`:

  ```clojure
  (list 1 2 3)            ; '(1 2 3)
  (list "apple" "orange") ; '("apple" "orange")
  (list 1 (list 2 3) 4)   ; '(1 (2 3) 4)
  ```
  Заметьте, что результаты вычисления показываются без упоминания имени функции "list", но зато с одинарной кавычкой перед открывающей скобкой.

  Дело в том, что в Clojure можно взять любое выражение в скобках и сказать интерпретатору, "не вычисляй его, а воспринимай как список". Такая операция называется "quotation" или "цитированием", а одинарная кавычка означает начало цитаты. Заканчивается же цитата там, где стоит закрывающая скобка, парная для той, что стоит после кавычки.

  Подробнее про цитирование вы узнаете позже (в модуле про макросы). Пока же рекомендуем вам использовать именно функцию `list` — именно потому, что это *функция*, а не специальный синтаксис.

  Если ещё раз посмотреть на примеры выше, то последний может навести на мысль: списки в Clojure *гетерогенные*, то есть любой список может одновременно содержать значения разных типов. В упомянутом примере в одном списке содержатся и числа, и вложенный список.

  ### Функция-предикат `list?`
  Чтобы узнать, является ли какое-то значение списком, используют функцию `list?`. Это распространённый приём — для каждого типа иметь функцию-тест с тем же именем и знаком вопроса в конце! Для строк это `string?`, для целых чисел это `integer?` и так далее.
instructions: |
  Реализуйте функцию `triple`, которая должна принимать один аргумент любого типа и возвращать список, в котором содержится три копии аргумента:

  ```clojure
  (triple "a") ; '("a" "a" "a")
  (triple 0)   ; '(0 0 0)
  ```
tips:
  - |
    [Официальная документация](https://clojure.org/guides/learn/sequential_colls#_lists)
  - |
    [Про цитирование](https://clojuredocs.org/clojure.core/quote)
