---

name: Объявление и вызов функций
theory: |
  Функции в Clojure обладают следующими свойствами:

  * У функций нет имен. Во многих языках такие функции также существуют и называются анонимными функциями или лямбда-функциями.
  * Функции являются объектами первого рода. Их можно присваивать переменным, передавать в другие функции и возвращать из функций.

  ```clojure
  ; определение функции, вычисляющей сумму двух чисел
  (fn [x y] (+ x y))
  ```

  В примере выше определяется функция с двумя аргументами. Определение функции начинается со слова `fn`. Вторым элементом в форме определения функции идёт список аргументов. Третий и последующие элементы — тело функции. То есть тело может состоять из нескольких форм (как минимум из одной):

  ```clojure
  (fn []
    (println "one")
    (println "two"))
  ```

  Обратите внимание на отсутствие инструкции `return`. В отличие от большинства других языков, в Lisp-языках "инструкций" практически нет. Всё есть выражение. А выражения всегда возвращают результат. Если хорошо подумать, то такое поведение следует из самой структуры Lisp-программы. Фактически мы имеем дерево, которое должно вычисляться в какое-то значение, значит на каждом уровне должен создаваться возврат, поднимающийся выше по дереву, и так до самого корня. Возвращается всегда *последнее вычисленное выражение*.
  Пара примеров для закрепления:

  ```clojure
  ; печать на экран
  (fn [] (println "hello!"))
  ; куб числа
  (fn [n] (* n n n))
  ; среднее между двумя числами
  (fn [num1 num2] (/ (+ num1 num2) 2))
  ```

  Определение функции само по себе мало полезно, особенно если мы захотим использовать её несколько раз. Для повторного использования нужно создать объявление, в которое запишется функция. Такое возможно благодаря тому, что форма определения функции — это выражение, возвращающее саму функцию.

  ```clojure
  (def cube (fn [n] (* n n n)))
  ```

  Теперь попробуем вызвать:

  ```clojure
  (cube 2) ; 8
  (cube 3) ; 27
  ```

  Помимо связи анонимной функции с объявлением существует упрощенный вариант объявления функции и связи ее с идентификатором. Делается это с помощью формы `defn`, которая делает процесс объявления функции удобнее (в таком способе объявления возможно даже написать документацию на объявляемую функцию!).

  ```clojure
  (defn cube [n] (* n n n))
  (cube 2)      ; => 8
  (cube 3)      ; => 27

  (defn increment
    "Function that increments passed number by one."
    [n] (+ n 1))
  (increment 2) ; => 3
  ```

instructions: |
  Создайте функцию с именем `square`, которая вычисляет квадрат переданного числа

  ```clojure
  (square 3) ; 9
  ```

definitions:
  - name: Объект первого рода
    description: Сущность в языке, которая рассматривается как данные. Это значит, что её можно записывать в переменную, передавать в функции и возвращать из функций.

tips:
  - |
    [Официальная документация](https://clojuredocs.org/clojure.core/defn)
