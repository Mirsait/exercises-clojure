---

name: Вызов функции без def
theory: |
  Вспомним функцию `cube` из прошлого урока:

  ```clojure
  (def cube (fn [n] (* n n n)))
  (cube 2) ; 8
  ```

  Попробуйте ответить на вопрос, можно ли вызывать функцию сразу после объявления без использования `def`? Конечно можно, как и во всех других языках с поддержкой анонимных функций. Для этого достаточно, в форме вызова, подставить вместо имени саму функцию:

  ```clojure
  ((fn [n] (* n n n)) 2) ; 8
  ```

  Необычность этой структуры в том, что здесь первый элемент не идентификатор, а выражение, возвращающее функцию (а определение анонимной функции возвращает саму функцию). Из-за этого возникает двойная скобка. Проще всего это понять, если всегда воспринимать скобки как вызов. В дальнейшем при работе со списками, как с данными, мы увидим, что это не всегда так, но на данном этапе данное упрощение полезно. В форме вызова сразу после функции перечисляются параметры. В данном примере параметр только один, это 2. Так будет выглядеть пример вызова функции с двумя аргументами:

  ```clojure
  ((fn [x y] (+ x y))
    2 3) ; 5
  ```

  Вызов функции — обычное выражение, это значит что его можно использовать во всех местах, где возможно появление выражения. В Lisp-языках это почти любые части программы:

  ```clojure
  (println ((fn [x y] (+ x y))
             8 7)) ; => 15
  ```

instructions: |
  1. Определите (без создания переменной) и вызовите функцию, которая находит среднее арифметическое между двумя числами. В качестве чисел подставьте 2 и 4.
  2. Запишите результат в переменную.
  3. Выведите переменную на экран.
definitions: []
tips:
  - |
    [Официальная документация](https://clojuredocs.org/clojure.core/fn)
  - |
    [Про лямбда-выражение](https://ru.wikipedia.org/wiki/%D0%9B%D1%8F%D0%BC%D0%B1%D0%B4%D0%B0-%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5)
  - |
    [Про лямбда-исчисление](https://ru.wikipedia.org/wiki/%D0%9B%D1%8F%D0%BC%D0%B1%D0%B4%D0%B0-%D0%B8%D1%81%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5)
