Система пространства имен в Clojure похожа на подобные системы в других языках. Каждый файл представляет собой пространство имен, которое совпадает с файловой системой:

```clojure
; math.clj
(ns math)
(defn sum [a b] (+ a b))
```

По умолчанию все объявления, сделанные в пространстве, экспортируются из модуля. Импорт объявлений из других модулей (читай "файлов") происходит с помощью формы `require`:

```clojure
(require '[math :refer [sum]])
```

Если есть необходимость не выставлять наружу какую-либо функцию, то используется форма `defn-`, которая превращает функцию в приватный метод (привет JVM):

```clojure
; math.clj
(defn- sum [a b] (+ a b))
```

Если мы попытаемся получить доступ из этого пространства имен, то возникнет ошибка импорта.

При импорте можно так же указать дополнительные параметры `(require '[math :refer :all])`. Таким образом мы экспортируем *все объявления в пространстве имен*. Если же мы хотим импортировать только конкретные формы, то используется следующий синтаксис `(require '[math :refer [sum]])`. Еще мы можем переименовывать пространства имен, для простоты адресации `(require '[math :as m])`. И еще одна удобная возможность, при определении пространства имен, мы можем импортировать другие. Важно, что `require` работает только с пространствами имен. В примере выше предполагается что оба файла с определениями лежат в одной директории.

Еще немного вариантов использования:

```clojure
; определяем наше пространство имен, импортируем пространство math
(ns my-ns
  (:require [math :as m]) ; переименовываем для упрощения

(defn my-cube [x] (m/cube x))
; ссылаемся на форму cube в пространстве имен math
```
