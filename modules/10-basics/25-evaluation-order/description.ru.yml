---

name: Порядок вычисления
theory: |
  Превратим выражение `5 - 3 + 1` в программу на Clojure. С точки зрения арифметики, порядок вычисления элементов этого составного выражения строго определен. Сначала вычисляется `5 - 3`, затем к результату прибавляется единица.

  Так как первым вычисляется `5 - 3` то получаем форму `(- 5  3)`. Затем сложим  результат с единицей: `(+ (- 5 3) 1)`. Так как операция сложения не зависит от расположения слагаемых то форму можно записать и в другом порядке: `(+ 1 (- 5 3))`. Неизменным остается то, что в начале каждого списка находится операция.

  Заметьте, выражения, вычисляемые первыми, расположены в глубине дерева. Такое поведение свойственно большинству языков. Сначала вычисляются аргументы функций, затем вызывается сама функция.

  Попробуем другой вариант: `5 - (3 + 1)`. В этом выражении скобки устанавливают другой приоритет. Это значит, что сначала вычислится сумма единицы и тройки. Так и запишем `(+ 3 1)` (или так `(+ 1 3)`). Теперь возьмём пятерку и вычтем из неё результат: `(- 5 (+ 1 3))`.

  В такие моменты проявляется ещё одно преимущество Lisp-языков. Древовидная структура программы сама определяет последовательность вычисления поддеревьев. Отпадает необходимость в дополнительных скобках.

  Ещё один пример: `5 + 7 + (8 - 3) - (8 * 5)`.
  * `(* 5 8)`
  * `(- 8 3)`
  * `(+ 5 7 (- 8 3))`
  * `(- (+ 5 7 (- 8 3)) (* 5 8))`

  В некоторых ситуациях порядок вычисления элементов списка не соответствует порядку их следования. Такое происходит при использовании специальных форм и макросов. Об этом поговорим позже.

instructions: |
  Выведите в стандартный поток вывода (с помощью функции `println`) следующее выражение: `100 - 34 - 22 - (5 + 3 - 10)`

tips: []
