---

name: Формы
theory: |
  Lisp-подобные языки называют языками без синтаксиса. Синтаксис у них конечно есть, но  примитивный. Состоит синтаксис из списков и значений. В популярных языках используется множество управляющих конструкций, таких как условия, циклы, возврат, присвоение переменных и так далее. В Lisp-подобные языках таких конструкций нет, но это не значит, что на Clojure нельзя реализовать цикл или написать условие.

  Каким же образом Clojure понимает, с чем работает и что нужно сделать? Все дело в _формах_. Любая корректная программа на Lisp называется _формой_. Например:

  ```clojure
  ; формы
  (println "some-str")
  (+ 1 2 3)
  (- 3)
  8
  "hello world!"

  ; а это не форма, такой код завершится ошибкой
  (1 2)
  Execution error (ClassCastException) at user/eval1 (REPL:1).
  class java.lang.Long cannot be cast to class clojure.lang.IFn (java.lang.Long is in module java.base of loader 'bootstrap'; clojure.lang.IFn is in unnamed module of loader 'app')
  ```

  Формы делятся на два типа — нормальная и составная. Нормальной соответствуют значения, которые вычисляются сами в себя, число _8_ или строка "hello". Составная форма — список, который нужно вычислить тем или иным способом.

instructions: |
  Выведите в стандартный поток вывода (с помощью функции `println`) результат вычисления следующего выражения: `- 23 * (- 3) + 15`
tips: []
