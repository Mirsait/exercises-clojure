True и False в Clojure представлены значениями `true` и `false` соответственно. Большинство операций в Clojure рассматривают как ложь только `false` и `nil` (отсутствие значения). Все остальное считается истиной. Пара примеров проверки на равенство:

```clojure
(= 42 42) ; true
(= 42 24) ; false
```

Равенство значений проверяется через функцию `=`. Напишем функцию `gt?`, которая возвращает `true`, если первое число больше второго и `false` в другом случае. В Clojure имена предикатов заканчиваются вопросительным знаком. При этом к ним не добавляется префикс "is".

```clojure
(defn gt? [x y] (> x y))
(gt? 3 2) ; true
(gt? 10 15) ; false
```

*Вот так разработчики на Ruby узнали почему в их языке предикаты выглядят как вопросы :)*
Теперь напишем предикат, определяющий четность числа. Для этого нам понадобится функция `rem`, которая вычисляет остаток от деления.

```clojure
(defn even? [n] (= (rem n 2) 0))
(even? 3) ; false
(even? 4) ; true
```

> Строго говоря, такая функция уже есть в языке. Здесь мы её реализуем заново только ради примера.
Логические операторы в Clojure не имеют символьных обозначений, вместо этого используются функции `and`, `or`, `not` и другие.

```clojure
(not "moon") ; false
(and (odd? 3) (even? 4)) ; true
```

Как и в случае с арифметическими операциями, мы получаем два бонуса:
1. Префиксная нотация позволяет комбинировать любое число условий: `(and <one> <two> <three> <...>)`.
2. Благодаря древовидной структуре исходного кода, приоритет всегда точно определен.
