---

name: Трансдьюсеры
theory: |
  Как уже было упомянуто, по умолчанию обработка коллекцией в Clojure знаменитой тройкой `map`, `filter` и `reduce` иммутабельна, что иногда может сильно увеличить расход памяти и время обработки коллекции большого размера. Однако в таких ситуациях на помощь приходят *трансдьюсеры*.

  Трансдьюсеры - это составные алгоритмические преобразования над коллекциями. Они независимы от контекста своих входных и выходных параметров и задают только суть преобразования в терминах отдельного элемента коллекции. Поскольку трансдьюсереы не зависят от ввода или вывода, их можно использовать в различных процессах - коллекциях, потоках, каналах и т. д.

  Редукционная функция - это такая функция, которую вы передаете для редукции, то есть - это функция, которая принимает накопленный результат и новую коллекцию и возвращает новый накопленный результат:

  ```clojure
  ;; сигнатура редукционной функции
  что угодно, вход -> что угодно
  ```

  Трансдьюсер (иногда называемый `xform` или `xf`) - это преобразование одной редуцирующей функции в другую:

  ```clojure
  ;; сигнатура преобразователя
  (что угодно, вход -> что угодно) -> (что угодно, вход -> что угодно)
  ```

  А теперь попробуем сделать свою трансформацию коллекции с помощью трансдьюсеров:

  ```clojure
  (filter odd?) ;; этот вызов возвращает трансдьюсер, который фильтрует нечетные числа
  (map inc)     ;; этот вызов возвращает трансдьюсер, который инкрементирует все числа на 1
  (take 5)      ;; этот вызов возвращает трансдьюсер, который берет из коллекции первые 5 чисел
  ```

  Трансдьюсеры компонуются с помощью обычной функциональной композиции. Рекомендуемый способ компоновки трансдьюсеров - это использование существующей функции `comp`:

  ```clojure
  (def xf
    (comp
      (filter odd?)
      (map inc)
      (take 5)))
  ```

  Трансдьюсер `xf` - это стек преобразований, который будет применен к переданным элементам. Каждая функция в стеке выполняется перед операцией, которую она обертывает. Композиция трансдьюсеров выполняется справа налево, но строит стек преобразований, который выполняется слева направо (в этом примере фильтрация происходит перед маппингом).

  В качестве мнемоники запомните, что упорядочивание функций трансдьюсеров в `comp` - имеет тот же порядок, что и преобразования последовательности в макросе `->>`. Пример выше эквивалентен следующему примеру:

  ```clojure
  (->> coll
    (filter odd?)
    (map inc)
    (take 5))
  ```

  Функции, которые можно использовать в качестве трансдьюсеров: `map`, `cat`, `mapcat`, `filter`, `remove`, `take`, `take-while`, `take-nth`, `drop`, `drop-while`, `replace`, `partition-by`, `partition-all`, `keep`, `keep-indexed`, `map-indexed`, `distinct`, `interpose`, `dedupe`, `random-sample`.

  А теперь посмотрим, как применять трансдьюсеры. Самым распространенным способом применения трансдьюсеров является использование функции `transduce`, которая является аналогом функции `reduce`, только для трансдьюсеров:

  ```clojure
  (transduce xform f coll)
  (transduce xform f init coll)
  ```

  `transduce` не лениво редуцирует `coll` с помощью преобразователя `xform`, применяемого к редуцирующей функции `f`, используя `init` в качестве начального значения, если оно предоставлено, или `f` в противном случае. `f` функция знает о том, как накапливать результат. А теперь примеры:

  ```clojure
  (def xf (comp (filter odd?) (map inc)))

  (transduce xf + (range 5))
  ;; => 6

  (transduce xf + 100 (range 5))
  ;; => 106
  ```

  `into` позволяет применять трансдьюсер к входной коллекции и создать на основе результата применения трансдьюсера новую коллекцию. Старайтесь по возможности использовать эту функцию, так как она применяет `reduce` эффективнее (без промежуточных коллекций), если есть такая возможность.

  ```clojure
  (into [] xf (range 10))
  [2 4 6 8 10]

  (into () xf (range 10)) ; => в списки элементы добавляются иначе, поэтому итоговый список в обратном порядке
  (10 8 6 4 2)

  (into #{} xf (range 10))
  #{4 6 2 10 8}
  ```

  Про создание трансдьюсеров поговорим в следующем упражнении.

instructions: |
  Скомбинируйте несколько трансдьюсеров в один `my-xf`, в котором происходит умножение всех элементов на 10, затем деление на 5, а затем выбор только четных элементов (фильтрация).

tips:
  - |
    [Выступление Рича Хикки про трансдьюсеры](https://www.youtube.com/watch?v=6mTbuzafcII)
  - |
    [Пост Рича Хикки про трансдьюсеры](https://cognitect.com/blog/2014/8/6/transducers-are-coming)
  - |
    [Когда стоит использовать трансдьюсеры](https://clojure.org/guides/faq#transducers_vs_seqs)
  - |
    [Официальная документация](https://clojure.org/reference/transducers)
  - |
    [Полезное про стратегии вычислений](https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D0%B0%D1%82%D0%B5%D0%B3%D0%B8%D1%8F_%D0%B2%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F)
  - |
    [Про трансдьюсеры на примере JS, 1](https://habr.com/ru/post/325388/)
  - |
    [Про трансдьюсеры на примере JS, 2](https://habr.com/ru/post/237613/)
